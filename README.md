# 구현 의도 및 주요 선택 사항
이 프로젝트는 다음과 같은 목표와 기준을 바탕으로 구현되었습니다.

## 1. 데이터 중심 정리
- UI와 로직을 설계할 때, **데이터 구조를 먼저 정의** 하고 그 위에 화면을 올리는 방식으로 구현했습니다.
- 화면이나 컴포넌트 변경이 필요할 때, 코드를 직접 수정하기보다 **데이터 변경만으로 동작이 달라지도록** 하는 것을 지향했습니다.
- 이를 통해 기능 확장 시 영향 범위를 줄이고,  테스트 시나리오를 데이터 레벨에서 정의할 수 있도록 했습니다.

## 2. 접근성(A11y) 고려: aria 속성과 시멘틱 태그 활용
- 각 섹션과 컴포넌트에 **적절한 시멘틱 태그** 를 사용하여 문서 구조를 명확히 했습니다.
- 스크린 리더 사용자를 고려하여 필요한 곳에는 **ARIA 속성** 을 추가했습니다.
- 키보드로만 조작 가능한 흐름을 염두에 두어, 포커스 이동과 의미 전달이 가능한 마크업을 유지하는 것을 목표로 했습니다.

## 3. 컴포넌트화 전략
- 재사용 가능한 UI 단위를 **명확히 잘게 나눠 컴포넌트화**했습니다.
- 역할 기준으로 컴포넌트를 나누되, 과도한 분리로 인해 가독성이 떨어지지 않도록 **실사용 관점에서 적당한 책임 범위**를 유지했습니다.
- 공통 스타일 및 패턴은 **공용 컴포넌트**로 추출해 중복 코드를 줄였습니다.

## 4. 스타일 구조: CSS Modules + SCSS
- 스타일 충돌을 방지하고 유지 보수성을 높이기 위해 **`module.scss` 기반의 CSS Modules**를 사용해 **컴포넌트 단위 스코프**를 부여했습니다.
- SCSS의 기능을 적극적으로 활용했습니다.
    - **mixin**: 반복되는 스타일 패턴(포지셔닝)을 재사용할 수 있도록 공통화
    - **함수**: 계산이 필요한 색상, 길이 등 스타일 값을 함수로 정의해 일관된 디자인 유지
    - **변수**: 색상 등을 변수로 관리해 디자인 시스템과 정합성을 맞춤
- 이 구조를 통해 각 컴포넌트는 자신의 스타일만 관리하고,  공통 설정은 SCSS 레이어에서 일관되게 관리하도록 했습니다.

## 5. Hook 분리 의도적으로 최소화
- 이번 구현에서는 **커스텀 Hook을 별도 디렉터리로 적극 분리하지 않도록 설계** 했습니다.
- 컴포넌트와 로직의 결합도가 높고 재사용 가능성이 낮은 경우, **불필요한 추상화를 피하고** 컴포넌트 파일 내에 로직을 두는 것이 더 직관적이라고 판단했습니다.
- 실제 재사용 요구가 생겼을 때 **필요한 시점에 커스텀 Hook으로 추출** 하는 방향을 선택하여, 초기 설계 단계에서의 오버 엔지니어링을 줄였습니다.

## 6. `@` 경로 별칭 사용
- import 가독성을 위해 **`@`를 활용한 경로 별칭(alias)** 을 적용했습니다.
- 이를 통해 상대 경로(`../../..`) 난립을 방지하고, 디렉터리 구조 변경 시에도 import 수정 범위를 최소화하는 것을 목표로 했습니다.

## 7. SEO(검색 엔진 최적화) 및 OG(Open Graph) 메타 태그
- **SEO를 고려한 메타 태그 구성** 을 적용했습니다.
- **Open Graph(OG) 메타 태그** 를 추가하여, SNS 및 메신저 링크 공유 시 썸네일 이미지, 제목, 설명 문구 등을 통일된 형태로 노출할 수 있도록 구성했습니다.

## 8. Storybook을 활용한 UI 문서화 및 협업
- UI 컴포넌트는 **Storybook을 활용해 문서화** 했습니다.
- 주요 목적:
    - **디자이너·개발자 간 협업** 시, 공통 기준이 되는 UI 카탈로그 역할을 수행.
    - 상태/변형(variants)·size·theme 등 다양한 조합을 한눈에 확인 가능.

## 9. 기타 고려 사항
- **일관성**: 코드 스타일(네이밍, 폴더 구조, 컴포넌트 패턴, 스타일 작성 규칙 등)의 일관성을 유지하여 협업 시 진입 장벽을 낮추도록 했습니다.
- **유지 보수성**: 기능 추가/수정 시 영향 범위를 명확히 파악할 수 있도록, 역할별·도메인별로 폴더와 컴포넌트를 구성했습니다.
- **확장성**: 초기 구현 단계에서부터 확장 가능성을 고려해, 공통 요소와 도메인 요소를 분리하고, 재사용 가능한 부분은 별도 모듈로 나눌 수 있는 구조를 염두에 두었습니다.
